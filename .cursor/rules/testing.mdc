---
description: 
globs: 
alwaysApply: true
---
# Teambition MCP 测试规范

## 测试目录结构

测试文件应遵循与源代码相同的目录结构，放在 `__tests__` 目录下：

```
src/
├── mcp-server/
│   └── tools/
│       └── user/
│           └── get-uid.ts
└── __tests__/
    └── mcp-server/
        └── tools/
            └── user/
                └── get-uid.test.ts
```

## 测试框架

本项目使用 Vitest 作为测试框架，提供以下功能：

- 单元测试
- 测试覆盖率报告
- 模拟 (Mocking)
- 测试 UI 界面

## 基本测试结构

```typescript
import { describe, it, expect, vi } from 'vitest'

// 导入被测试的模块
import { functionToTest } from '../../../path/to/module'

describe('模块名称', () => {
  // 设置
  beforeEach(() => {
    // 每个测试前的准备工作
  })
  
  afterEach(() => {
    // 每个测试后的清理工作
    vi.restoreAllMocks()
  })
  
  it('应该正确处理正常情况', () => {
    // 准备
    const input = {}
    
    // 执行
    const result = functionToTest(input)
    
    // 断言
    expect(result).toBe(expectedOutput)
  })
  
  it('应该正确处理错误情况', () => {
    // 错误情况测试
  })
})
```

## MCP 工具测试模式

测试 MCP 工具时，应使用以下模式：

```typescript
import { describe, it, expect, vi } from 'vitest'
import type { TbMCPServer } from '../../../../mcp-server/server'
import { registerXxxTool } from '../../../../mcp-server/tools/xxx'

describe('xxx_tool 工具', () => {
  it('应成功处理有效请求', async () => {
    // 1. 模拟 MCP 服务器
    const mockServer = {
      defineDirectFunction: vi.fn(),
    }
    const tbMCPServer = { server: mockServer } as unknown as TbMCPServer
    
    // 2. 注册工具
    registerXxxTool(tbMCPServer)
    
    // 3. 获取处理函数
    const defineDirectFunctionMock = mockServer.defineDirectFunction.mock
    expect(defineDirectFunctionMock.calls.length).toBe(1)
    
    const { handler } = defineDirectFunctionMock.calls[0][0]
    
    // 4. 模拟外部依赖（如果有）
    vi.spyOn(someService, 'someMethod').mockResolvedValue(mockResult)
    
    // 5. 执行测试
    const result = await handler({
      param1: 'value1',
      param2: 'value2',
    })
    
    // 6. 验证结果
    expect(result.success).toBe(true)
    expect(result.data).toEqual({
      expectedKey: 'expectedValue',
    })
  })
  
  it('应正确处理错误情况', async () => {
    // ... 同上设置 ...
    
    // 模拟错误
    vi.spyOn(someService, 'someMethod').mockRejectedValue(new Error('测试错误'))
    
    // 执行测试
    const result = await handler({
      param1: 'value1',
    })
    
    // 验证错误结果
    expect(result.success).toBe(false)
    expect(result.error).toContain('测试错误')
  })
})
```

## 测试覆盖率

- 目标测试覆盖率：80%+
- 运行测试覆盖率报告：`pnpm test:coverage`
- 关注以下覆盖率指标：
  - 语句覆盖率 (Statements)
  - 分支覆盖率 (Branches)
  - 函数覆盖率 (Functions)
  - 行覆盖率 (Lines)

## 模拟 (Mocking)

### 函数模拟

```typescript
// 模拟函数
const mockFn = vi.fn().mockReturnValue('模拟返回值')

// 模拟异步函数
const mockAsyncFn = vi.fn().mockResolvedValue('模拟异步返回值')
// 或者模拟异步错误
const mockAsyncFn = vi.fn().mockRejectedValue(new Error('模拟错误'))

// 模拟已有函数
vi.spyOn(object, 'method').mockImplementation(() => '模拟实现')
```

### 模块模拟

```typescript
// 模拟整个模块
vi.mock('module-name', () => ({
  function1: vi.fn().mockReturnValue('模拟返回值'),
  function2: vi.fn().mockImplementation((arg) => arg),
}))
```

## 测试命令

- 运行所有测试：`pnpm test`
- 运行特定测试文件：`pnpm test path/to/test.test.ts`
- 观察模式：`pnpm test --watch`
- 生成覆盖率报告：`pnpm test:coverage`
- 使用 UI 运行测试：`pnpm test:ui`

## 断言最佳实践

- 使用精确的断言，如 `toEqual` 而非 `toBeTruthy`
- 针对对象使用 `toEqual` 而非 `toBe`
- 测试异步代码使用 `async/await` 而非回调
- 对于异常测试使用 `toThrow`

```typescript
// 良好实践
expect(result).toEqual({ key: 'value' })

// 避免
expect(result.key).toBe('value')
```

## 集成测试

对于需要测试多个模块交互的场景，创建集成测试：

```typescript
import { describe, it, expect } from 'vitest'
import { startServer } from '../../../mcp-server/server'

describe('MCP 服务器集成测试', () => {
  it('应成功启动并注册所有工具', async () => {
    // 测试服务器启动和工具注册过程
  })
})
```
